syntax = "proto3";

package rumble.api.v1;

// Phase 2 additions: rooms, voice, and richer server events

message Login {
  string username = 1; // placeholder, real auth in phase 3
}

message RoomId {
  uint64 value = 1;
}

message UserId {
  uint64 value = 1;
}

message JoinRoom {
  RoomId room_id = 1;
}

message LeaveRoom {
  RoomId room_id = 1;
}

message RoomInfo {
  RoomId id = 1;
  string name = 2;
}

message RoomState {
  repeated RoomInfo rooms = 1;
  repeated UserPresence users = 2; // users present per room
}

message UserPresence {
  UserId user_id = 1;
  RoomId room_id = 2;
  string username = 3;
}

// Voice datagram sent via QUIC datagrams (unreliable, low-latency).
// This is a standalone message not wrapped in Envelope for minimal overhead.
//
// Client -> Server: Only opus_data and sequence are required.
//   The server determines sender_id and room_id from the connection.
//
// Server -> Client: All fields are populated by the server.
//   sender_id and room_id are set by the server based on the sender's
//   authenticated identity and current room membership.
message VoiceDatagram {
  // Opus-encoded audio frame (required)
  bytes opus_data = 1;
  
  // Sequence number for ordering/jitter buffer (client should increment)
  uint32 sequence = 2;
  
  // Timestamp in microseconds (client's capture time, for jitter buffer sync)
  // Optional: if not set, receiver can use arrival time
  uint64 timestamp_us = 3;
  
  // --- Fields set by server on relay, ignored if sent by client ---
  
  // User ID of the sender (set by server based on authenticated connection)
  optional uint64 sender_id = 10;
  
  // Room ID where this audio originated (set by server based on sender's room)
  optional uint64 room_id = 11;
}

// Extend the existing ServerEvent with additional variants for Phase 2.

// Generic envelope that carries a single payload and an optional state hash.
// For simplicity we model payload as oneof of known types.
message Envelope {
  bytes state_hash = 1; // protobuf-canonicalized checksum
  oneof payload {
    ClientHello client_hello = 10;
    ServerHello server_hello = 11;
    ChatMessage chat_message = 12;
    Disconnect disconnect = 13;
    ServerEvent server_event = 14;
    Login login = 15;
    JoinRoom join_room = 16;
    LeaveRoom leave_room = 17;
    RoomState room_state_msg = 18;
    // Field 19 reserved: was VoiceFrame, now removed (voice uses datagrams only)
    CreateRoom create_room = 20;
    DeleteRoom delete_room = 21;
    RenameRoom rename_room = 22;
    RequestStateSync request_state_sync = 23;
  }
}

// Sent by client immediately after connecting and opening the control stream.
message ClientHello {
  string client_name = 1;
  // Optional authentication password; if server requires one, must match.
  string password = 2;
}

// Initial response from server.
message ServerHello {
  string server_name = 1;
  // The user_id assigned to this client by the server.
  // This is determined by the server based on the connection, not claimed by the client.
  uint64 user_id = 2;
}

// Chat message sent from client to server.
message ChatMessage {
  string sender = 1;
  string text = 2;
}

// Events pushed from server to clients.
message ServerEvent {
  oneof kind {
    ChatBroadcast chat_broadcast = 1;
    // Periodic keep-alive ping from the server.
    KeepAlive keep_alive = 2;
    // Full state snapshot (used for initial sync and resync)
    RoomState room_state_update = 3;
    // Incremental user joined notification
    UserPresence user_joined = 4;
    // Incremental user left notification  
    UserPresence user_left = 5;
    // Field 6 reserved: was VoiceFrame, now removed (voice uses datagrams only)
    // Incremental state update with hash for verification
    StateUpdate state_update = 7;
  }
}

// Incremental state update message.
// Contains a single state change and the expected hash after applying it.
// Client applies the update locally and verifies the resulting hash.
// If mismatch, client requests a full resync.
message StateUpdate {
  // The state hash AFTER this update is applied.
  // Client should compute its local hash after applying and compare.
  bytes expected_hash = 1;
  
  oneof update {
    // A user moved to a different room
    UserMoved user_moved = 10;
    // A new room was created
    RoomCreated room_created = 11;
    // A room was deleted
    RoomDeleted room_deleted = 12;
    // A room was renamed
    RoomRenamed room_renamed = 13;
    // A user's presence changed (joined server, left server, name change)
    UserPresenceChanged user_presence_changed = 14;
  }
}

// Incremental update: user moved to a different room
message UserMoved {
  UserId user_id = 1;
  RoomId from_room_id = 2;
  RoomId to_room_id = 3;
}

// Incremental update: new room created
message RoomCreated {
  RoomInfo room = 1;
}

// Incremental update: room deleted
message RoomDeleted {
  RoomId room_id = 1;
  // Users that were in the room are moved to fallback_room_id (usually Root)
  RoomId fallback_room_id = 2;
}

// Incremental update: room renamed
message RoomRenamed {
  RoomId room_id = 1;
  string old_name = 2;
  string new_name = 3;
}

// Incremental update: user presence changed
message UserPresenceChanged {
  UserPresence user = 1;
  // Type of change
  enum ChangeType {
    JOINED_SERVER = 0;
    LEFT_SERVER = 1;
    NAME_CHANGED = 2;
  }
  ChangeType change_type = 2;
}

// Room management requests
message CreateRoom { string name = 1; }
message DeleteRoom { uint64 room_id = 1; }
message RenameRoom { uint64 room_id = 1; string new_name = 2; }

// Request a full state resync from the server.
// Sent by the client when it detects a state hash mismatch.
message RequestStateSync {
  // The hash the client expected (for debugging/logging).
  bytes expected_hash = 1;
  // The hash the client computed locally (for debugging/logging).
  bytes actual_hash = 2;
}

// Broadcast of a chat message to all connected clients.
message ChatBroadcast {
  string sender = 1;
  string text = 2;
}

// Empty keep-alive message with optional timestamp.
message KeepAlive {
  uint64 epoch_ms = 1;
}

// Graceful disconnect notification.
message Disconnect {
  string reason = 1;
}
