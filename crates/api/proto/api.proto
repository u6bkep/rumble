syntax = "proto3";

package rumble.api.v1;

// Phase 2 additions: rooms, voice, and richer server events

message Login {
  string username = 1; // placeholder, real auth in phase 3
}

message RoomId {
  uint64 value = 1;
}

message UserId {
  uint64 value = 1;
}

message JoinRoom {
  RoomId room_id = 1;
}

message LeaveRoom {
  RoomId room_id = 1;
}

message RoomInfo {
  RoomId id = 1;
  string name = 2;
}

message RoomState {
  repeated RoomInfo rooms = 1;
  repeated UserPresence users = 2; // users present per room
}

message UserPresence {
  UserId user_id = 1;
  RoomId room_id = 2;
  string username = 3;
}

// Voice datagram sent via QUIC datagrams (unreliable, low-latency).
// This is a standalone message not wrapped in Envelope for minimal overhead.
//
// Client -> Server: Only opus_data and sequence are required.
//   The server determines sender_id and room_id from the connection.
//
// Server -> Client: All fields are populated by the server.
//   sender_id and room_id are set by the server based on the sender's
//   authenticated identity and current room membership.
message VoiceDatagram {
  // Opus-encoded audio frame (required)
  bytes opus_data = 1;
  
  // Sequence number for ordering/jitter buffer (client should increment)
  uint32 sequence = 2;
  
  // Timestamp in microseconds (client's capture time, for jitter buffer sync)
  // Optional: if not set, receiver can use arrival time
  uint64 timestamp_us = 3;
  
  // --- Fields set by server on relay, ignored if sent by client ---
  
  // User ID of the sender (set by server based on authenticated connection)
  optional uint64 sender_id = 10;
  
  // Room ID where this audio originated (set by server based on sender's room)
  optional uint64 room_id = 11;
}

// Extend the existing ServerEvent with additional variants for Phase 2.

// Generic envelope that carries a single payload and an optional state hash.
// For simplicity we model payload as oneof of known types.
message Envelope {
  bytes state_hash = 1; // protobuf-canonicalized checksum
  oneof payload {
    ClientHello client_hello = 10;
    ServerHello server_hello = 11;
    ChatMessage chat_message = 12;
    Disconnect disconnect = 13;
    ServerEvent server_event = 14;
    Login login = 15;
    JoinRoom join_room = 16;
    LeaveRoom leave_room = 17;
    RoomState room_state_msg = 18;
    // Field 19 reserved: was VoiceFrame, now removed (voice uses datagrams only)
    CreateRoom create_room = 20;
    DeleteRoom delete_room = 21;
    RenameRoom rename_room = 22;
  }
}

// Sent by client immediately after connecting and opening the control stream.
message ClientHello {
  string client_name = 1;
  // Optional authentication password; if server requires one, must match.
  string password = 2;
}

// Initial response from server.
message ServerHello {
  string server_name = 1;
  // The user_id assigned to this client by the server.
  // This is determined by the server based on the connection, not claimed by the client.
  uint64 user_id = 2;
}

// Chat message sent from client to server.
message ChatMessage {
  string sender = 1;
  string text = 2;
}

// Events pushed from server to clients.
message ServerEvent {
  oneof kind {
    ChatBroadcast chat_broadcast = 1;
    // Periodic keep-alive ping from the server.
    KeepAlive keep_alive = 2;
    RoomState room_state_update = 3;
    UserPresence user_joined = 4;
    UserPresence user_left = 5;
    // Field 6 reserved: was VoiceFrame, now removed (voice uses datagrams only)
  }
}

// Room management requests
message CreateRoom { string name = 1; }
message DeleteRoom { uint64 room_id = 1; }
message RenameRoom { uint64 room_id = 1; string new_name = 2; }

// Broadcast of a chat message to all connected clients.
message ChatBroadcast {
  string sender = 1;
  string text = 2;
}

// Empty keep-alive message with optional timestamp.
message KeepAlive {
  uint64 epoch_ms = 1;
}

// Graceful disconnect notification.
message Disconnect {
  string reason = 1;
}
